# -*- coding: utf-8 -*-
"""Final Stasja Hackethon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kosW_HeXocRcxrmXojXRHRuUYAFVTDea
"""

# Install necessary libraries
!pip install pdf2image pillow
!apt-get install -y poppler-utils

# Import necessary libraries
import os
from pdf2image import convert_from_path
from PIL import Image
import matplotlib.pyplot as plt

# Define the path to your PDF file
pdf_file = "/content/1628877planritning.pdf"
print(f"Using PDF file: {pdf_file}")

# Convert PDF to images (list of PIL images)
images = convert_from_path(pdf_file)

# Get the first page of the PDF
image = images[0]

# Save the first page as a JPEG image
jpeg_path = "/content/page.jpg"
image.save(jpeg_path, "JPEG")
print(f"Saved JPEG image at: {jpeg_path}")

# Display the converted image
plt.figure(figsize=(10, 10))
plt.imshow(image)
plt.title("Converted PDF Page")
plt.axis("off")
plt.show()

from PIL import Image
import matplotlib.pyplot as plt

# Define the path to your JPEG image
jpg_path = "/content/page.jpg"

# Open the JPEG image
img = Image.open(jpg_path)
width, height = img.size
print(f"Original dimensions: {width}x{height}")

# Set cropping parameters (pixels to remove from each side)
crop_left = 50   # Crop 50 pixels from left
crop_top = 400    # Crop 50 pixels from top
crop_right = 50  # Crop 50 pixels from right
crop_bottom = 570 # Crop 50 pixels from bottom

# Calculate the crop box coordinates
new_left = crop_left
new_top = crop_top
new_right = width - crop_right
new_bottom = height - crop_bottom

# Crop the image
cropped_img = img.crop((new_left, new_top, new_right, new_bottom))
new_width, new_height = cropped_img.size
print(f"New dimensions after cropping: {new_width}x{new_height}")

# Display the original and cropped images side by side
plt.figure(figsize=(20, 10))

plt.subplot(1, 2, 1)
plt.imshow(img)
plt.title("Before Cropping")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(cropped_img)
plt.title("After Cropping")
plt.axis("off")

plt.show()

# Install Roboflow SDK
!pip install inference-sdk

# Install Roboflow SDK
!pip install inference-sdk

# Import necessary libraries
from inference_sdk import InferenceHTTPClient
from PIL import Image, ImageDraw
import requests
import json
import matplotlib.pyplot as plt

# Initialize the Roboflow inference client
CLIENT = InferenceHTTPClient(
    api_url="https://detect.roboflow.com",
    api_key="b41v5SAggi3P0hFQRvgf"
)

# Ensure we are using the correct image path
cropped_image_path = "/content/page.jpg"  # Make sure this is the correct path
cropped_img = Image.open(cropped_image_path)  # Load image

# Perform inference using Roboflow for window and door detection
result = CLIENT.infer(cropped_image_path, model_id="door-windows/1")

# Display the raw JSON response
print("Roboflow Detection Results:")
print(json.dumps(result, indent=4))

# Load the image again to draw detections
detected_image = cropped_img.copy()
draw = ImageDraw.Draw(detected_image)

# Extract detected objects and draw bounding boxes
for prediction in result['predictions']:
    x, y, w, h = prediction['x'], prediction['y'], prediction['width'], prediction['height']
    label = prediction['class']

    # Convert center x,y and width,height to bounding box (top-left, bottom-right)
    x1, y1 = int(x - w / 2), int(y - h / 2)
    x2, y2 = int(x + w / 2), int(y + h / 2)

    # Draw bounding box
    draw.rectangle([x1, y1, x2, y2], outline="red", width=3)

    # Add label text
    draw.text((x1, y1 - 10), label, fill="red")

# Display the image with detections
plt.figure(figsize=(10, 10))
plt.imshow(detected_image)
plt.title("Detected Windows & Doors")
plt.axis('off')
plt.show()

import numpy as np
import cv2
import matplotlib.pyplot as plt

# --- Step 2: Generate a Heatmap Based on Window/Door Detections ---

# Extract detected object centers from Roboflow's result
centers = []
for pred in result['predictions']:
    # Extract center coordinates (assuming Roboflow returns these as 'x' and 'y')
    cx = float(pred['x'])
    cy = float(pred['y'])
    centers.append((cx, cy))

# Convert the cropped image to a NumPy array to get dimensions
cropped_np = np.array(cropped_img)
h, w = cropped_np.shape[:2]

# Create an empty heatmap array
heatmap = np.zeros((h, w), dtype=np.float32)

# Set the standard deviation for the Gaussian (adjust sigma as needed)
sigma = 50.0

# Create a coordinate grid
Y, X = np.mgrid[0:h, 0:w]

# Add a Gaussian blob at each detected center
for (cx, cy) in centers:
    # Ensure integer coordinates
    cx = int(round(cx))
    cy = int(round(cy))
    # Compute the Gaussian: exp(-((x-cx)^2 + (y-cy)^2) / (2*sigma^2))
    gaussian_blob = np.exp(-((X - cx)**2 + (Y - cy)**2) / (2 * sigma**2))
    heatmap += gaussian_blob

# Restrict the heatmap to the interior area (if interior_mask is defined)
# interior_mask should be a binary mask (uint8) with interior = 255.
try:
    interior_mask
except NameError:
    # If not defined, assume the entire image is interior.
    interior_mask = np.ones((h, w), dtype=np.uint8) * 255

# Apply the interior mask (convert mask to float in range [0,1] and multiply)
heatmap_masked = heatmap * (interior_mask.astype(np.float32) / 255.0)

# Normalize the heatmap to the range [0, 255] for display
heatmap_norm = cv2.normalize(heatmap_masked, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

# Apply a color map to visualize the heatmap
heatmap_color = cv2.applyColorMap(heatmap_norm, cv2.COLORMAP_JET)

# Display the resulting heatmap
plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(heatmap_color, cv2.COLOR_BGR2RGB))
plt.title("Heatmap of Window/Door Influence")
plt.axis('off')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Assume heatmap_norm is your normalized grayscale heatmap (0-255)
# and heatmap_color is your colored heatmap (BGR) from previous steps.
# Adjust threshold_value as needed to remove low-intensity blue areas.
threshold_value = 100

# Create a binary mask: pixels with intensity below threshold become 0, above become 255.
_, mask = cv2.threshold(heatmap_norm, threshold_value, 255, cv2.THRESH_BINARY)
# Invert the mask so that low-intensity areas become white in the overlay.
mask_inv = cv2.bitwise_not(mask)

# Copy the original colored heatmap.
final_heatmap = heatmap_color.copy()

# Where the inverted mask is nonzero (i.e. where the intensity was below threshold), set those pixels to white.
final_heatmap[mask_inv > 0] = [255, 255, 255]

plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(final_heatmap, cv2.COLOR_BGR2RGB))
plt.title("Final Heatmap (Threshold Applied)")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Assume heatmap_norm is your normalized grayscale heatmap (0-255)
# and heatmap_color is your colored heatmap (BGR) from previous steps.
# Adjust threshold_value as needed to remove low-intensity blue areas.
threshold_value = 100

# Create a binary mask: pixels with intensity below threshold become 0, above become 255.
_, mask = cv2.threshold(heatmap_norm, threshold_value, 255, cv2.THRESH_BINARY)
# Invert the mask so that low-intensity areas become white in the overlay.
mask_inv = cv2.bitwise_not(mask)

# Copy the original colored heatmap.
final_heatmap = heatmap_color.copy()

# Where the inverted mask is nonzero (i.e. where the intensity was below threshold), set those pixels to white.
final_heatmap[mask_inv > 0] = [255, 255, 255]

plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(final_heatmap, cv2.COLOR_BGR2RGB))
plt.title("Final Heatmap (Threshold Applied)")
plt.axis("off")
plt.show()

nt

import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# Convert the cropped image to grayscale
gray_img = np.array(cropped_img.convert("L"))

# Apply thresholding so that high-intensity (white) areas (walls) remain white
# Adjust the threshold value (200 here) as needed based on your image
ret, binary_img = cv2.threshold(gray_img, 200, 255, cv2.THRESH_BINARY)

# Optional: Clean up the binary image by filling small gaps using morphological closing
kernel = np.ones((3, 3), np.uint8)
closed_img = cv2.morphologyEx(binary_img, cv2.MORPH_CLOSE, kernel, iterations=2)

# Display the resulting image (white walls on black background)
plt.figure(figsize=(10, 10))
plt.imshow(closed_img, cmap='gray')
plt.title("White Walls on Black Background")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# Convert the cropped PIL image to grayscale
gray_img = np.array(cropped_img.convert("L"))

# Invert the grayscale image
inverted_img = cv2.bitwise_not(gray_img)

# Display the inverted image
plt.figure(figsize=(10, 10))
plt.imshow(inverted_img, cmap='gray')
plt.title("Inverted Image")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Set a threshold value (adjust as needed; 128 is a common default)
threshold_value = 128

# Apply binary thresholding to the inverted image.
# Pixels greater than threshold_value become 255 (white) and others become 0 (black)
ret, threshold_img = cv2.threshold(inverted_img, threshold_value, 255, cv2.THRESH_BINARY)

# Display the thresholded image
plt.figure(figsize=(10, 10))
plt.imshow(threshold_img, cmap='gray')
plt.title("Thresholded Inverted Image")
plt.axis("off")
plt.show()

from ipywidgets import interact, IntSlider
import cv2
import numpy as np
import matplotlib.pyplot as plt

def threshold_with_slider(threshold_value=128):
    # Apply binary thresholding to the inverted image using the slider value.
    ret, threshold_img = cv2.threshold(inverted_img, threshold_value, 255, cv2.THRESH_BINARY)

    # Display the thresholded image
    plt.figure(figsize=(10, 10))
    plt.imshow(threshold_img, cmap='gray')
    plt.title(f"Thresholded Inverted Image (Threshold = {threshold_value})")
    plt.axis("off")
    plt.show()

# Create an interactive slider from 0 to 255
interact(threshold_with_slider, threshold_value=IntSlider(min=0, max=255, step=1, value=128))

# Direct approach to clean the floor plan
import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# Make sure we have the cropped image converted to OpenCV format
cropped_cv = cv2.cvtColor(np.array(cropped_img), cv2.COLOR_RGB2BGR)
gray = cv2.cvtColor(cropped_cv, cv2.COLOR_BGR2GRAY)

# 1. Start with basic thresholding to get the walls
_, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)

# 2. Remove very small elements (dots)
kernel = np.ones((3, 3), np.uint8)
cleaned = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

# 3. Get connected components to identify and remove furniture and text
nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(cleaned, connectivity=8)
sizes = stats[1:, -1]

# 4. Create a mask with only the large elements (walls)
clean_walls = np.zeros_like(cleaned)
min_area = 1000  # Try a higher value to remove more elements

# 5. Keep only the largest connected components (likely walls)
# Sort components by size (descending)
indices = np.argsort(sizes)[::-1]

# Keep only the N largest components
num_to_keep = 20  # Adjust this number as needed
for i in range(min(num_to_keep, len(indices))):
    idx = indices[i]
    if sizes[idx] >= min_area:  # Only keep if it's above minimum size
        clean_walls[output == idx + 1] = 255

# 6. Final cleanup
clean_walls = cv2.morphologyEx(clean_walls, cv2.MORPH_CLOSE, kernel, iterations=2)

# Display the results
plt.figure(figsize=(15, 10))

plt.subplot(1, 2, 1)
plt.imshow(binary, cmap='gray')
plt.title("Original Binary")
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(clean_walls, cmap='gray')
plt.title("Cleaned Walls")
plt.axis('off')

plt.tight_layout()
plt.show()

# Save the clean result
clean_image = Image.fromarray(clean_walls)
clean_path = "/content/clean_walls_final.png"
clean_image.save(clean_path)
print(f"Saved cleaned walls: {clean_path}")



import cv2
import numpy as np
import matplotlib.pyplot as plt

# Convert the final threshold image (clean_walls, a binary image) to a 3-channel BGR image.
plan_bgr = cv2.cvtColor(clean_walls, cv2.COLOR_GRAY2BGR)

# Ensure both images have the same dimensions.
if final_heatmap.shape[:2] != plan_bgr.shape[:2]:
    final_heatmap = cv2.resize(final_heatmap, (plan_bgr.shape[1], plan_bgr.shape[0]))

# Blend the images: adjust alpha and beta to control the overlay
alpha = 0.6  # Weight for the plan (background)
beta = 0.4   # Weight for the heatmap (overlay)
overlay = cv2.addWeighted(plan_bgr, alpha, final_heatmap, beta, 0)

# Display the overlay result
plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
plt.title("Overlay: Heatmap on Final Threshold Image")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Increase the brightness of the pixelated heatmap
bright_factor = 1.5  # Adjust this value for more or less brightness
bright_heatmap = cv2.convertScaleAbs(pixelated_heatmap, alpha=bright_factor, beta=0)

# Convert the binary plan (clean_walls) to a 3-channel BGR image
plan_bgr = cv2.cvtColor(clean_walls, cv2.COLOR_GRAY2BGR)

# Blend the bright heatmap with the plan image using weighted overlay
alpha = 0.6  # weight for the underlying plan
beta  = 0.4  # weight for the bright heatmap overlay
overlay = cv2.addWeighted(plan_bgr, alpha, bright_heatmap, beta, 0)

# Display the final overlay result
plt.figure(figsize=(10, 10))
plt.imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
plt.title("Overlay: Bright Pixelated Heatmap on Threshold Plan")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# --- Step 1: Generate an Enlarged Heatmap from Window/ Door Detections ---

# Extract detected object centers from the Roboflow result
centers = []
for pred in result['predictions']:
    cx = float(pred['x'])
    cy = float(pred['y'])
    centers.append((cx, cy))

# Get dimensions from the cropped plan image (assume cropped_img is a PIL image)
cropped_np = np.array(cropped_img)
h, w = cropped_np.shape[:2]

# Create a coordinate grid
Y, X = np.mgrid[0:h, 0:w]

# Initialize a blank heatmap (float32)
heatmap = np.zeros((h, w), dtype=np.float32)

# Use a larger sigma (e.g., 100) so that each Gaussian blob covers a larger area
sigma = 100.0

# For each detected window/door, add a Gaussian blob to the heatmap
for (cx, cy) in centers:
    # Ensure center coordinates are integers
    cx = int(round(cx))
    cy = int(round(cy))
    # Create the Gaussian blob
    gaussian_blob = np.exp(-((X - cx)**2 + (Y - cy)**2) / (2 * sigma**2))
    heatmap += gaussian_blob

# Normalize the heatmap to the range [0, 255]
heatmap_norm = cv2.normalize(heatmap, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

# Convert the normalized heatmap to a colored image using a colormap (JET)
enlarged_heatmap = cv2.applyColorMap(heatmap_norm, cv2.COLORMAP_JET)

# --- Step 2: Overlay the Heatmap on the Threshold Plan (White Walls on Black) ---

# Convert the binary plan image (clean_walls) to a 3-channel BGR image
plan_bgr = cv2.cvtColor(clean_walls, cv2.COLOR_GRAY2BGR)

# Ensure that both images are the same size (they should be, if from the same cropped plan)
if enlarged_heatmap.shape[:2] != plan_bgr.shape[:2]:
    enlarged_heatmap = cv2.resize(enlarged_heatmap, (plan_bgr.shape[1], plan_bgr.shape[0]))

# Blend the plan and the heatmap so that the heatmap is overlaid on top.
# Since the plan's background is black, the heatmap will be visible only on the interior.
alpha = 0.5  # weight for the plan (background)
beta  = 0.5  # weight for the heatmap overlay
overlay = cv2.addWeighted(plan_bgr, alpha, enlarged_heatmap, beta, 0)

# --- Display the Results ---
plt.figure(figsize=(12, 12))
plt.imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
plt.title("Overlay: Enlarged Heatmap on Threshold Plan")
plt.axis("off")
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# --- Pixelate the Enlarged Heatmap ---
# Adjust the pixel_scale_factor: 0.07 should yield a moderate pixel size.
pixel_scale_factor = 0.03  # Adjust this value to change block size
h, w = enlarged_heatmap.shape[:2]

# Downscale the heatmap to create a pixelated version
small_heatmap = cv2.resize(enlarged_heatmap, (int(w * pixel_scale_factor), int(h * pixel_scale_factor)), interpolation=cv2.INTER_LINEAR)
# Upscale back using nearest neighbor interpolation to preserve blockiness
pixelated_heatmap = cv2.resize(small_heatmap, (w, h), interpolation=cv2.INTER_NEAREST)

# --- Prepare the Threshold Plan Layer ---
# Convert the binary plan image (clean_walls) to a 3-channel BGR image.
plan_bgr = cv2.cvtColor(clean_walls, cv2.COLOR_GRAY2BGR)

# Ensure both layers have the same dimensions.
if pixelated_heatmap.shape[:2] != plan_bgr.shape[:2]:
    pixelated_heatmap = cv2.resize(pixelated_heatmap, (plan_bgr.shape[1], plan_bgr.shape[0]))

# --- Overlay the Pixelated Heatmap on the Plan ---
alpha = 0.5  # Weight for the plan layer
beta = 0.5   # Weight for the pixelated heatmap layer
overlay = cv2.addWeighted(plan_bgr, alpha, pixelated_heatmap, beta, 0)

# Display the final overlay
plt.figure(figsize=(12, 12))
plt.imshow(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB))
plt.title("Overlay: Pixelated Heatmap (Intermediate Pixel Size) on Threshold Plan")
plt.axis("off")
plt.show()

import ipywidgets as widgets
from IPython.display import display
import cv2
import numpy as np
import matplotlib.pyplot as plt

def display_layers(mode="Overlay", heatmap_alpha=0.5):
    if mode == "Walls Only":
        # Display just the plan (walls)
        img_to_show = plan_bgr
    elif mode == "Heatmap Only":
        # Display just the pixelated heatmap
        img_to_show = pixelated_heatmap
    elif mode == "Overlay":
        # Blend the two layers: heatmap over the plan.
        # Weight for the plan is 1 - heatmap_alpha and for the heatmap is heatmap_alpha.
        overlay = cv2.addWeighted(plan_bgr, 1 - heatmap_alpha, pixelated_heatmap, heatmap_alpha, 0)
        img_to_show = overlay

    plt.figure(figsize=(10, 10))
    plt.imshow(cv2.cvtColor(img_to_show, cv2.COLOR_BGR2RGB))
    plt.title(mode)
    plt.axis("off")
    plt.show()

# Interactive widget to select the display mode and adjust heatmap opacity when in Overlay mode.
mode_selector = widgets.Dropdown(options=["Walls Only", "Heatmap Only", "Overlay"],
                                   value="Overlay", description="Display Mode:")
heatmap_alpha_slider = widgets.FloatSlider(value=0.5, min=0, max=1, step=0.05, description="Heatmap Opacity:")

widgets.interactive(display_layers, mode=mode_selector, heatmap_alpha=heatmap_alpha_slider)

import ipywidgets as widgets
from IPython.display import display
import cv2
import numpy as np
import matplotlib.pyplot as plt

def display_layers(mode="Overlay", heatmap_alpha=0.5, crop_left=0, crop_top=0, crop_right=0, crop_bottom=0):
    # Select the base image based on the chosen mode.
    if mode == "Walls Only":
        # Use the apartment plan (white walls on black) as a BGR image.
        img_to_show = plan_bgr.copy()
    elif mode == "Heatmap Only":
        # Use just the pixelated heatmap layer.
        img_to_show = pixelated_heatmap.copy()
    elif mode == "Overlay":
        # Blend the two layers: heatmap over the plan.
        overlay = cv2.addWeighted(plan_bgr, 1 - heatmap_alpha, pixelated_heatmap, heatmap_alpha, 0)
        img_to_show = overlay.copy()

    # Apply cropping: remove 'crop_left' pixels from left, 'crop_top' from top,
    # 'crop_right' from right, and 'crop_bottom' from bottom.
    h_img, w_img = img_to_show.shape[:2]
    # Calculate new boundaries
    x1 = int(crop_left)
    y1 = int(crop_top)
    x2 = w_img - int(crop_right)
    y2 = h_img - int(crop_bottom)

    # Ensure the cropping boundaries are valid.
    if x1 < 0 or y1 < 0 or x2 > w_img or y2 > h_img or x1 >= x2 or y1 >= y2:
        cropped_img = img_to_show
    else:
        cropped_img = img_to_show[y1:y2, x1:x2]

    plt.figure(figsize=(10, 10))
    plt.imshow(cv2.cvtColor(cropped_img, cv2.COLOR_BGR2RGB))
    plt.title(mode)
    plt.axis("off")
    plt.show()

# Interactive widget parameters:
mode_selector = widgets.Dropdown(options=["Walls Only", "Heatmap Only", "Overlay"],
                                   value="Overlay", description="Display Mode:")
heatmap_alpha_slider = widgets.FloatSlider(value=0.5, min=0, max=1, step=0.05, description="Heatmap Opacity:")
crop_left_slider = widgets.IntSlider(value=0, min=0, max=300, step=1, description="Crop Left:")
crop_top_slider = widgets.IntSlider(value=0, min=0, max=500, step=1, description="Crop Top:")
crop_right_slider = widgets.IntSlider(value=0, min=0, max=300, step=1, description="Crop Right:")
crop_bottom_slider = widgets.IntSlider(value=0, min=0, max=900, step=1, description="Crop Bottom:")

# Create interactive display
widgets.interactive(display_layers,
                     mode=mode_selector,
                     heatmap_alpha=heatmap_alpha_slider,
                     crop_left=crop_left_slider,
                     crop_top=crop_top_slider,
                     crop_right=crop_right_slider,
                     crop_bottom=crop_bottom_slider)